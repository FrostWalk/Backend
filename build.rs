use std::env;
use std::fs;
use std::path::Path;
use std::process::Command;

fn main() {
    // Check if this is a dev build
    let is_dev_build = env::var("IS_DEV_BUILD").unwrap_or_else(|_| "false".to_string()) == "true";

    println!("cargo:warning=Is dev build: {}", is_dev_build);

    // Set git tag based on whether it's a dev build
    // For dev pipeline, we use "dev" as git tag
    // For release pipeline, we use the actual git tag
    let git_tag = if is_dev_build {
        "dev".to_string()
    } else {
        get_git_tag()
    };

    println!("cargo:warning=Git tag: {}", git_tag);

    // Get git commit hash
    let git_commit = get_git_commit();

    // Get build time
    let build_time = chrono::Utc::now().to_rfc3339();

    // Get Rust version
    let rust_version = get_rust_version();

    // Create build info content
    let build_info = format!(
        "// This file is auto-generated by build.rs
// DO NOT EDIT MANUALLY

pub const GIT_TAG: &str = \"{}\";
pub const GIT_COMMIT: &str = \"{}\";
pub const BUILD_TIME: &str = \"{}\";
pub const RUSTC_VERSION: &str = \"{}\";
",
        git_tag, git_commit, build_time, rust_version
    );

    // Write to OUT_DIR
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("build_info.rs");
    fs::write(&dest_path, build_info).unwrap();

    // Tell Cargo to re-run this build script if any of these change
    println!("cargo:rerun-if-changed=.git/HEAD");
    println!("cargo:rerun-if-changed=.git/refs");
}

fn get_git_tag() -> String {
    // First, try to get from Woodpecker CI environment variable
    if let Ok(ci_tag) = env::var("CI_COMMIT_TAG") {
        if !ci_tag.is_empty() {
            return ci_tag;
        }
    }

    // If in CI but no tag, use a default version
    if env::var("CI_COMMIT_SHA").is_ok() {
        return "0.1.0".to_string();
    }

    // Fall back to git describe for local builds (includes commit info and dirty status)
    match Command::new("git")
        .args(["describe", "--tags", "--always", "--dirty"])
        .output()
    {
        Ok(output) => {
            if output.status.success() {
                String::from_utf8_lossy(&output.stdout).trim().to_string()
            } else {
                "unknown".to_string()
            }
        }
        Err(_) => "unknown".to_string(),
    }
}

fn get_git_commit() -> String {
    // First, try to get from Woodpecker CI environment variable
    if let Ok(ci_commit) = env::var("CI_COMMIT_SHA") {
        if !ci_commit.is_empty() {
            return ci_commit;
        }
    }

    // Fall back to git command for local builds
    match Command::new("git").args(["rev-parse", "HEAD"]).output() {
        Ok(output) => {
            if output.status.success() {
                String::from_utf8_lossy(&output.stdout).trim().to_string()
            } else {
                "unknown".to_string()
            }
        }
        Err(_) => "unknown".to_string(),
    }
}

fn get_rust_version() -> String {
    match Command::new("rustc").args(["--version"]).output() {
        Ok(output) => {
            if output.status.success() {
                String::from_utf8_lossy(&output.stdout).trim().to_string()
            } else {
                "unknown".to_string()
            }
        }
        Err(_) => "unknown".to_string(),
    }
}
