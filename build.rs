use std::env;
use std::fs;
use std::path::Path;
use std::process::Command;

fn main() {
    // Get git tag (latest tag)
    let mut git_tag = get_git_tag();

    // Check if we're building in dev profile and append "-dev" suffix
    let profile = env::var("PROFILE").unwrap_or_else(|_| "release".to_string());
    if profile == "dev" {
        git_tag = format!("{}-dev", git_tag);
    }

    // Get git commit hash
    let git_commit = get_git_commit();

    // Get build time
    let build_time = chrono::Utc::now().to_rfc3339();

    // Get Rust version
    let rust_version = get_rust_version();

    // Create build info content
    let build_info = format!(
        "// This file is auto-generated by build.rs
// DO NOT EDIT MANUALLY

pub const GIT_TAG: &str = \"{}\";
pub const GIT_COMMIT: &str = \"{}\";
pub const BUILD_TIME: &str = \"{}\";
pub const RUSTC_VERSION: &str = \"{}\";
",
        git_tag, git_commit, build_time, rust_version
    );

    // Write to OUT_DIR
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("build_info.rs");
    fs::write(&dest_path, build_info).unwrap();

    // Tell Cargo to re-run this build script if any of these change
    println!("cargo:rerun-if-changed=.git/HEAD");
    println!("cargo:rerun-if-changed=.git/refs");
}

fn get_git_tag() -> String {
    // First, try to get from Woodpecker CI environment variable
    if let Ok(ci_tag) = env::var("CI_COMMIT_TAG") {
        if !ci_tag.is_empty() {
            return ci_tag;
        }
    }

    // If in CI but no tag, try to get the latest tag from history
    if env::var("CI_COMMIT_SHA").is_ok() {
        // We're in CI, try to get the latest tag
        if let Ok(output) = Command::new("git")
            .args(&["describe", "--tags", "--abbrev=0"])
            .output()
        {
            if output.status.success() {
                let tag = String::from_utf8_lossy(&output.stdout).trim().to_string();
                if !tag.is_empty() {
                    return tag;
                }
            }
        }
        // If no tags found at all, use a default version
        return "0.1.0".to_string();
    }

    // Fall back to git describe for local builds (includes commit info and dirty status)
    match Command::new("git")
        .args(&["describe", "--tags", "--always", "--dirty"])
        .output()
    {
        Ok(output) => {
            if output.status.success() {
                String::from_utf8_lossy(&output.stdout).trim().to_string()
            } else {
                "unknown".to_string()
            }
        }
        Err(_) => "unknown".to_string(),
    }
}

fn get_git_commit() -> String {
    // First, try to get from Woodpecker CI environment variable
    if let Ok(ci_commit) = env::var("CI_COMMIT_SHA") {
        if !ci_commit.is_empty() {
            return ci_commit;
        }
    }

    // Fall back to git command for local builds
    match Command::new("git").args(&["rev-parse", "HEAD"]).output() {
        Ok(output) => {
            if output.status.success() {
                String::from_utf8_lossy(&output.stdout).trim().to_string()
            } else {
                "unknown".to_string()
            }
        }
        Err(_) => "unknown".to_string(),
    }
}

fn get_rust_version() -> String {
    match Command::new("rustc").args(&["--version"]).output() {
        Ok(output) => {
            if output.status.success() {
                String::from_utf8_lossy(&output.stdout).trim().to_string()
            } else {
                "unknown".to_string()
            }
        }
        Err(_) => "unknown".to_string(),
    }
}
