clone:
  git:
    image: woodpeckerci/plugin-git
    settings:
      depth: 0
      tags: true
    when:
      - event: manual
        branch: main
      - event: tag

steps:
  # ---------- DISCOVER RELEASE TAG ----------
  compute-release-tag:
    image: alpine/git:latest
    commands:
      - set -e
      - |
        # Skip unless it's a tag event or a manual run explicitly asking for a release
        if [ "$CI_PIPELINE_EVENT" = "manual" ] && [ "${RUN_RELEASE:-}" != "true" ]; then
          echo "Skipping release: RUN_RELEASE!=true on manual run."
          exit 0
        fi

        if [ "$CI_PIPELINE_EVENT" = "tag" ] && [ -n "$CI_COMMIT_TAG" ]; then
          TAG="$CI_COMMIT_TAG"
        elif [ -n "${OVERRIDE_TAG:-}" ]; then
          TAG="$OVERRIDE_TAG"
        else
          # Use the newest existing tag from the clone (no network)
          TAG="$(git describe --tags --abbrev=0 2>/dev/null || git tag --sort=-creatordate | head -n1 || true)"
          if [ -z "$TAG" ]; then
            echo "No git tags found. On manual runs set RUN_RELEASE=true and provide OVERRIDE_TAG (e.g., v1.0.0)." >&2
            exit 1
          fi
        fi

        printf "%s\n%s\n" "$TAG" "latest" > .tags
        echo "Release tags:"
        cat .tags
    when:
      - event: tag
      - event: manual
        branch: main

  # ---------- RELEASE IMAGE (backend:<tag> and :latest) ----------
  docker-build-release:
    image: woodpeckerci/plugin-docker-buildx
    depends_on: [compute-release-tag]
    settings:
      registry: ghcr.io
      repo: ghcr.io/frostwalk/backend
      tags_file: .tags
      dockerfile: Dockerfile
      build_args:
        PROFILE: release
      build_args_from_env: true
      labels:
        - org.opencontainers.image.source=https://github.com/frostwalk/backend
        - org.opencontainers.image.licenses=MIT
        - org.opencontainers.image.description="Release image of the backend"
      default_labels: true
      username:
        from_secret: GHCR_USERNAME
      password:
        from_secret: GHCR_TOKEN
    when:
      - event: tag
      - event: manual
        branch: main

  # ---------- CVE SCAN (fail on HIGH/CRITICAL) ----------
  trivy-scan-release:
    image: ghcr.io/aquasecurity/trivy:latest
    depends_on:
      - docker-build-release
    environment:
      GHCR_USERNAME:
        from_secret: GHCR_USERNAME
      GHCR_TOKEN:
        from_secret: GHCR_TOKEN
    commands:
      - set -e
      - echo "$GHCR_TOKEN" | trivy registry login --username "$GHCR_USERNAME" --password-stdin ghcr.io
      - |
        while read -r t; do
          echo "Scanning ghcr.io/frostwalk/backend:${t}"
          trivy image --timeout 5m --severity HIGH,CRITICAL --exit-code 1 ghcr.io/frostwalk/backend:"${t}"
          trivy image --format table ghcr.io/frostwalk/backend:"${t}" > "trivy-report-${t}.txt"
        done < .tags
    when:
      - event: tag
      - event: manual
        branch: main

  # ---------- prepare Docker auth for Syft ----------
  prepare-docker-config:
    image: alpine:latest
    depends_on:
      - trivy-scan-release
    environment:
      GHCR_USERNAME:
        from_secret: GHCR_USERNAME
      GHCR_TOKEN:
        from_secret: GHCR_TOKEN
    commands:
      - set -e
      - mkdir -p .docker
      - AUTH=$(printf "%s:%s" "$GHCR_USERNAME" "$GHCR_TOKEN" | base64 | tr -d '\n')
      - printf '{"auths":{"ghcr.io":{"auth":"%s"}}}\n' "$AUTH" > .docker/config.json
    when:
      - event: tag
      - event: manual
        branch: main

  # ---------- SBOM (CycloneDX) with Syft ----------
  # Builds SBOM from :latest (same digest as the release tag produced in this pipeline).
  sbom-generate-release:
    image: anchore/syft:latest
    depends_on:
      - prepare-docker-config
    environment:
      DOCKER_CONFIG: .docker
    entrypoint:
      - /syft
      - ghcr.io/frostwalk/backend:latest
      - -o
      - cyclonedx-json=sbom.cdx.json
    when:
      - event: tag
      - event: manual
        branch: main

  # ---------- SIGN ----------
  cosign-sign-release:
    image: cgr.dev/chainguard/cosign:latest
    depends_on:
      - sbom-generate-release
    environment:
      GHCR_USERNAME:
        from_secret: GHCR_USERNAME
      GHCR_TOKEN:
        from_secret: GHCR_TOKEN
      COSIGN_PRIVATE_KEY:
        from_secret: COSIGN_PRIVATE_KEY
      COSIGN_PASSWORD:
        from_secret: COSIGN_PASSWORD
    commands:
      - set -e
      - cosign login ghcr.io -u "$GHCR_USERNAME" -p "$GHCR_TOKEN"
      - printf "%s" "$COSIGN_PRIVATE_KEY" > cosign.key
      - |
        while read -r t; do
          echo "Signing ghcr.io/frostwalk/backend:${t}"
          cosign sign --yes --key cosign.key ghcr.io/frostwalk/backend:"${t}"
        done < .tags
    when:
      - event: tag
      - event: manual
        branch: main

  # ---------- SIGN SBOM (attestation) ----------
  cosign-attest-sbom-release:
    image: cgr.dev/chainguard/cosign:latest
    depends_on:
      - sbom-generate-release
    environment:
      GHCR_USERNAME:
        from_secret: GHCR_USERNAME
      GHCR_TOKEN:
        from_secret: GHCR_TOKEN
      COSIGN_PRIVATE_KEY:
        from_secret: COSIGN_PRIVATE_KEY
      COSIGN_PASSWORD:
        from_secret: COSIGN_PASSWORD
    commands:
      - set -e
      - cosign login ghcr.io -u "$GHCR_USERNAME" -p "$GHCR_TOKEN"
      - printf "%s" "$COSIGN_PRIVATE_KEY" > cosign.key
      - |
        while read -r t; do
          echo "Attesting SBOM to ghcr.io/frostwalk/backend:${t}"
          cosign attest --yes --key cosign.key --type cyclonedx --predicate sbom.cdx.json ghcr.io/frostwalk/backend:"${t}"
        done < .tags
    when:
      - event: tag
      - event: manual
        branch: main

  # ---------- VERIFY ----------
  cosign-verify-release:
    image: cgr.dev/chainguard/cosign:latest
    depends_on:
      - cosign-sign-release
      - cosign-attest-sbom-release
    environment:
      GHCR_USERNAME:
        from_secret: GHCR_USERNAME
      GHCR_TOKEN:
        from_secret: GHCR_TOKEN
      COSIGN_PUBLIC_KEY:
        from_secret: COSIGN_PUBLIC_KEY
    commands:
      - set -e
      - cosign login ghcr.io -u "$GHCR_USERNAME" -p "$GHCR_TOKEN"
      - printf "%s" "$COSIGN_PUBLIC_KEY" > cosign.pub
      - |
        while read -r t; do
          echo "Verifying signature for ghcr.io/frostwalk/backend:${t}"
          cosign verify --key cosign.pub ghcr.io/frostwalk/backend:"${t}" >/dev/null
        done < .tags
    when:
      - event: tag
      - event: manual
        branch: main

  # ---------- TRIGGER UPGRADE ----------
  trigger-watchtower:
    image: curlimages/curl:latest
    environment:
      WT_URL: https://wt.advancedprogramming.ovh/v1/update
      WT_TOKEN:
        from_secret: WATCHTOWER_TOKEN
    commands:
      - 'curl -fsS -X POST -H "Authorization: Bearer $${WT_TOKEN}" "$WT_URL"'
    depends_on:
      - cosign-verify-release
    when:
      - event: manual
        branch: main
      - event: tag
